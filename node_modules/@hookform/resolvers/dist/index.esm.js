import { transformToNestObject, appendErrors } from 'react-hook-form';

const parseErrorSchema = (error, validateAllFieldCriteria) => Array.isArray(error.inner)
    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (path
        ? previous[path] && validateAllFieldCriteria
            ? {
                [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),
            }
            : {
                [path]: previous[path] || Object.assign({ message,
                    type }, (validateAllFieldCriteria
                    ? {
                        types: { [type]: message || true },
                    }
                    : {})),
            }
        : {}))), {})
    : {
        [error.path]: { message: error.message, type: error.type },
    };
const yupResolver = (schema, options = {
    abortEarly: false,
}) => async (values, _, validateAllFieldCriteria = false) => {
    try {
        return {
            values: (await schema.validate(values, Object.assign({}, options))),
            errors: {},
        };
    }
    catch (e) {
        return {
            values: {},
            errors: transformToNestObject(parseErrorSchema(e, validateAllFieldCriteria)),
        };
    }
};

var convertArrayToPathName = (paths) => paths
    .reduce((previous, path, index) => `${previous}${typeof path === 'string'
    ? `${index > 0 ? '.' : ''}${path}`
    : `[${path}]`}`, '')
    .toString();

const parseErrorSchema$1 = (error, validateAllFieldCriteria) => Array.isArray(error.failures)
    ? error.failures.reduce((previous, { path, message = '', type }) => {
        const currentPath = convertArrayToPathName(path);
        return Object.assign(Object.assign({}, previous), (path
            ? previous[currentPath] && validateAllFieldCriteria
                ? {
                    [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type || '', message),
                }
                : {
                    [currentPath]: previous[currentPath] || Object.assign({ message,
                        type }, (validateAllFieldCriteria
                        ? {
                            types: { [type || '']: message || true },
                        }
                        : {})),
                }
            : {}));
    }, {})
    : [];
const superstructResolver = (schema) => async (values, _, validateAllFieldCriteria = false) => {
    try {
        return {
            values: schema(values),
            errors: {},
        };
    }
    catch (e) {
        return {
            values: {},
            errors: transformToNestObject(parseErrorSchema$1(e, validateAllFieldCriteria)),
        };
    }
};

const parseErrorSchema$2 = (error, validateAllFieldCriteria) => Array.isArray(error.details)
    ? error.details.reduce((previous, { path, message = '', type }) => {
        const currentPath = convertArrayToPathName(path);
        return Object.assign(Object.assign({}, previous), (path
            ? previous[currentPath] && validateAllFieldCriteria
                ? {
                    [currentPath]: appendErrors(currentPath, validateAllFieldCriteria, previous, type, message),
                }
                : {
                    [currentPath]: previous[currentPath] || Object.assign({ message,
                        type }, (validateAllFieldCriteria
                        ? {
                            types: { [type]: message || true },
                        }
                        : {})),
                }
            : {}));
    }, {})
    : [];
const joiResolver = (schema, options = {
    abortEarly: false,
}) => async (values, _, validateAllFieldCriteria = false) => {
    try {
        return {
            values: await schema.validateAsync(values, Object.assign({}, options)),
            errors: {},
        };
    }
    catch (e) {
        return {
            values: {},
            errors: transformToNestObject(parseErrorSchema$2(e, validateAllFieldCriteria)),
        };
    }
};

export { joiResolver, superstructResolver, yupResolver };
//# sourceMappingURL=index.esm.js.map
